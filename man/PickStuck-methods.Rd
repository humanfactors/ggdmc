% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analysis.R, R/diagnosis.R, R/model-class.R
\docType{methods}
\name{CheckConverged}
\alias{CheckConverged}
\alias{PickStuck}
\alias{PickStuck,posterior-method}
\alias{PickStuck,list-method}
\alias{PickStuck,hyper-method}
\alias{isstuck}
\alias{isstuck,posterior-method}
\alias{isstuck,list-method}
\alias{isstuck,hyper-method}
\alias{isflat}
\alias{isflat,posterior-method}
\alias{isflat,list-method}
\alias{ismixed}
\alias{ismixed,posterior-method}
\title{Convergence Diagnosis}
\usage{
CheckConverged(x)

CheckConverged(x)

PickStuck(x, ...)

\S4method{PickStuck}{posterior}(x, cut = 10, start = 1, end = NA,
  verbose = FALSE, digits = 2)

\S4method{PickStuck}{list}(x, cut = 10, start = 1, end = NA,
  verbose = FALSE, digits = 2)

\S4method{PickStuck}{hyper}(x, hyper = TRUE, cut = 10, start = 1,
  end = NA, verbose = FALSE, digits = 2)

isstuck(x, ...)

\S4method{isstuck}{posterior}(x, cut = 10, start = 1, end = NA,
  verbose = FALSE)

\S4method{isstuck}{list}(x, cut = 10, start = 1, end = NA,
  verbose = FALSE, digits = 2)

\S4method{isstuck}{hyper}(x, hyper = TRUE, cut = 10, start = 1,
  end = NA, verbose = FALSE, digits = 2)

isflat(x, ...)

\S4method{isflat}{posterior}(x, p1 = 1/3, p2 = 1/3, cut = 0.25,
  cut_scale = Inf, verbose = FALSE, digits = 2)

\S4method{isflat}{list}(x, p1 = 1/3, p2 = 1/3, cut = 0.25,
  cut_scale = Inf, verbose = FALSE, digits = 2)

ismixed(x, ...)

\S4method{ismixed}{posterior}(x, cut = 1.1, verbose = FALSE)
}
\arguments{
\item{x}{posterior samples}

\item{...}{other additional arguments}

\item{cut}{a criterion for deciding whether chains get stuck
(\code{isstuck}); whether chains are not flat
(using median or IQR \code{isflat}); whether chains are well mixed
\code{ismixed}.}

\item{start}{start to evaluate from which iteration.}

\item{end}{end at which iteration for evaeuation.}

\item{verbose}{a boolean switch to print more information}

\item{digits}{print how many digits. Default is 2}

\item{hyper}{whether x are hierarhcial samples}

\item{p1}{the range of the head of MCMC chains}

\item{p2}{the range of the tail of the MCMC chains}

\item{cut_scale}{Use IQR to decide whether chains are not flat}
}
\value{
\code{PickStuck} gives an index vector; \code{unstick} gives a
posterios samples.
}
\description{
These functions test whether Markov chains are converged .
}
\details{
\code{isstuck} tests whether a chain hovers around a region significantly
deviates from other its peers.

\code{PickStuck} calculate each chain separately for the mean (across
MC samples) of posterior log likelihood. If the difference of the means and
the median (across chains) of the mean of posterior log likelihood
is greater than the value set in \code{cut}, chains are considered stuck.
The default value for \code{cut} is 10. The user should consider their
situatin to set the cut value.

\code{unstick} removes stuck chains from posterior samples (not well tested).

\code{ismixed} tests whether the potential scale reduction factor for a
model fit is lower than a criterion, defined by \code{cut}.

\code{iseffective} testes whether posterior samples are enough adjusted
autocorrelation.

\code{CheckConverged} is a wrapper function running the four checking
functions, \code{isstuck}, \code{isflat}, \code{ismixed} and \code{iseffective}.
}
\examples{
model <- BuildModel(
p.map     = list(a = "1", v="1", z="1", d="1", sz="1", sv="1", t0="1",
                 st0="1"),
match.map = list(M = list(s1 = "r1", s2 = "r2")),
factors   = list(S = c("s1", "s2")),
responses = c("r1","r2"),
constants = c(st0 = 0, d = 0, sv = 0, sz = 0),
type      = "rd")

npar <- model@npar
pop.mean  <- c(a=2,   v=4, z=0.5, t0=0.3)
pop.scale <- c(a=0.5, v=.5, z=0.1, t0=0.05)
pop.prior <- BuildPrior(
  dists = rep("tnorm", npar),
  p1    = pop.mean,
  p2    = pop.scale,
  lower = c(0,-5,  0, 0),
  upper = c(5, 7,  1, 1))

dat <- simulate(model, nsub = 8, nsim = 30, prior = pop.prior)
dmi <- BuildDMI(dat, model)
ps <- attr(dat, "parameters")

p.prior <- BuildPrior(
  dists = rep("tnorm", npar),
  p1    = pop.mean,
  p2    = pop.scale*5,
  lower = c(0,-5, 0, 0),
  upper = c(5, 7, 1, 1))

mu.prior <- BuildPrior(
  dists = rep("tnorm", npar),
  p1    = pop.mean,
  p2    = pop.scale*5,
  lower = c(0,-5,  0, 0),
  upper = c(5, 7,  1, 1))

sigma.prior <- BuildPrior(
  dists = rep("beta", npar),
  p1    = c(a=1, v=1, z=1, t0=1),
  p2    = rep(1, npar),
  upper = rep(1, npar))

## Note the names are important
priors <- list(pprior=p.prior, location=mu.prior, scale=sigma.prior)

\dontrun{
Fit hierarchical model ----##
fit0 <- StartNewsamples(dmi, priors)
fit  <- run(fit0)

PickStuck(fit, hyper=TRUE)
PickStuck(fit@individuals[[1]])
PickStuck(fit)

tmp <- PickStuck(fit, hyper=TRUE, verbose=T)
tmp <- PickStuck(fit@individuals[[1]], verbose=T)
tmp <- PickStuck(fit, verbose=T)
isstuck(fit0@individuals[[1]])
isstuck(fit@individuals[[1]])
isstuck(fit, hyper = TRUE)

tmp <- isflat(fit@individuals[[1]])
tmp <- isflat(fit@individuals[[1]], verbose = TRUE)

tmp <- isflat(fit@individuals[[1]], cut_scale = .25)
tmp <- isflat(fit@individuals[[1]], cut_scale = .25, verbose = TRUE)

## Test unstick
fit0 <- StartNewsamples(dmi, priors, nmc=50)
fit  <- run(fit0, nmc=200)
bad <- PickStuck(fit@individuals[[1]], verbose=T)
chain_removed <- unstick_one(fit@individuals[[1]], bad)
plot(tmp)
}
}
